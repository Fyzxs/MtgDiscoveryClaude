@using RazorConsole.Components
@using Spectre.Console
@using System.Threading.Tasks
@inject DashboardState State

<Border BoxBorder="@BoxBorder.Double" BorderColor="@Color.Blue">
    <Rows>
        <Align Horizontal="@HorizontalAlignment.Center">
            <Markup Content="Scryfall Bulk Ingestion Progress" Foreground="@Color.White" />
        </Align>

        <Newline />

        @if (!string.IsNullOrEmpty(State.ProgressType))
        {
            <ProgressSection
                Type="@State.ProgressType"
                Current="@State.ProgressCurrent"
                Total="@State.ProgressTotal"
                CurrentItem="@GetCurrentItem()" />
        }
        else
        {
            @if (State.SetTotal > 0)
            {
                <ProgressSection
                    Type="Sets"
                    Current="@State.SetCurrent"
                    Total="@State.SetTotal"
                    CurrentItem="@State.SetName" />
            }
            else if (State.CardTotal > 0 || State.CardCurrent > 0)
            {
                <ProgressSection
                    Type="Cards"
                    Current="@State.CardCurrent"
                    Total="@State.CardTotal"
                    CurrentItem="@State.CardName" />
            }
            else if (State.TrigramTotal > 0 || State.TrigramCurrent > 0)
            {
                <ProgressSection
                    Type="Trigrams"
                    Current="@State.TrigramCurrent"
                    Total="@State.TrigramTotal"
                    CurrentItem="@State.TrigramName" />
            }
            else if (State.RulingTotal > 0 || State.RulingCurrent > 0)
            {
                <ProgressSection
                    Type="Rulings"
                    Current="@State.RulingCurrent"
                    Total="@State.RulingTotal"
                    CurrentItem="@State.RulingName" />
            }
            else
            {
                <Markup Content="Status: Waiting to start..." Foreground="@Color.Grey" />
            }
        }

        <CompletedCountsSection Counts="@State.CompletedCounts" />

        <RecentActivitySection Logs="@State.RecentLogs" />

        <Newline />
        <Border BoxBorder="@BoxBorder.Rounded" BorderColor="@Color.Grey">
            <SystemMetricsSection MemoryMB="@State.MemoryUsage" Elapsed="@State.Elapsed" />
        </Border>

        @if (State.IsComplete)
        {
            <Newline />
            <Markup Content="@State.CompletionMessage" Foreground="@Color.Green" />
        }

        <Newline />
        <Align Horizontal="@HorizontalAlignment.Center">
            @if (State.IsComplete)
            {
                <Border BoxBorder="@BoxBorder.Rounded" BorderColor="@Color.Grey">
                    <Markup Content=" Press [X] to Exit " Foreground="@Color.White" />
                </Border>
            }
            else
            {
                <Border BoxBorder="@BoxBorder.Rounded" BorderColor="@Color.Red">
                    <Markup Content=" Press [C] to Cancel " Foreground="@Color.Yellow" />
                </Border>
            }
        </Align>
    </Rows>
</Border>

@code {
    private Task _keyListenerTask;
    private bool _disposed;

    protected override Task OnInitializedAsync()
    {
        // Start the update loop in a background task so the component can render
        _ = Task.Run(async () =>
        {
            while (State.IsComplete is false && _disposed is false)
            {
                State.UpdateMemoryUsage();
                await InvokeAsync(StateHasChanged).ConfigureAwait(false);
                await Task.Delay(100).ConfigureAwait(false);
            }

            await InvokeAsync(StateHasChanged).ConfigureAwait(false);
        });

        // Start key listener task
        _keyListenerTask = Task.Run(async () =>
        {
            while (_disposed is false)
            {
                if (Console.KeyAvailable)
                {
                    ConsoleKeyInfo key = Console.ReadKey(true);

                    if (State.IsComplete is false && (key.Key == ConsoleKey.C || key.KeyChar == 'c' || key.KeyChar == 'C'))
                    {
                        State.RequestCancellation();
                        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
                    }
                    else if (State.IsComplete && (key.Key == ConsoleKey.X || key.KeyChar == 'x' || key.KeyChar == 'X'))
                    {
                        Environment.Exit(0);
                    }
                }

                await Task.Delay(50).ConfigureAwait(false);
            }
        });

        return Task.CompletedTask;
    }

    private string GetCurrentItem()
    {
        if (!string.IsNullOrEmpty(State.ProgressItem))
        {
            return string.IsNullOrEmpty(State.ProgressAction)
                ? State.ProgressItem
                : $"{State.ProgressAction} - {State.ProgressItem}";
        }
        return State.ProgressAction;
    }

    public void Dispose()
    {
        _disposed = true;
        if (_keyListenerTask is not null)
        {
            _keyListenerTask.Wait(TimeSpan.FromSeconds(1));
        }
    }
}
